<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Performance Globe - Demo Quality</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #globe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }
        
        .controls h3 {
            margin: 0 0 15px 0;
            color: #00ff88;
            font-size: 18px;
        }
        
        .controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: #111;
            color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .controls button:hover {
            background: #222;
            border-color: #00ff88;
        }
        
        .controls button.active {
            background: #00ff88;
            color: #000;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            min-width: 250px;
        }
        
        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        .info-panel .stat {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .country-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
        }
        
        .loading h2 {
            color: #00ff88;
            margin-bottom: 20px;
        }
        
        .loading .progress {
            width: 300px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading .progress-bar {
            height: 100%;
            background: #00ff88;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .performance-stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            font-size: 12px;
        }
        
        .data-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .data-panel h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        .data-item {
            margin: 5px 0;
            font-size: 12px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="globe-container"></div>
        
        <div class="loading" id="loading">
            <h2>Initializing Hybrid Performance Globe</h2>
            <div class="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div id="loading-text">Loading...</div>
        </div>
        
        <div class="controls" id="controls" style="display: none;">
            <h3>Hybrid Globe Controls</h3>
            <button onclick="toggleAutoRotate()" id="rotate-btn">Auto Rotate</button>
            <button onclick="toggleWireframe()" id="wireframe-btn">Show Wireframe</button>
            <button onclick="togglePerformanceMode()" id="perf-btn">Performance Mode</button>
            <button onclick="toggleDataDisplay()" id="data-btn">Data Display</button>
            <button onclick="resetView()">Reset View</button>
            <button onclick="exportData()">Export Data</button>
        </div>
        
        <div class="info-panel" id="info-panel" style="display: none;">
            <h4>Globe Statistics</h4>
            <div class="stat">Total Points: <span id="total-points">0</span></div>
            <div class="stat">Countries: <span id="total-countries">195</span></div>
            <div class="stat">Active Points: <span id="active-points">0</span></div>
            <div class="stat">FPS: <span id="fps">0</span></div>
            <div class="stat">Resolution: <span id="resolution">Auto</span></div>
            
            <div class="country-info" id="country-info" style="display: none;">
                <h4>Selected Country</h4>
                <div id="country-name">None</div>
                <div id="country-id">ID: -</div>
                <div id="country-points">Points: 0</div>
            </div>
        </div>
        
        <div class="data-panel" id="data-panel" style="display: none;">
            <h4>Country Data</h4>
            <div id="data-content">
                <div class="data-item">Population: <span id="population">-</span></div>
                <div class="data-item">Area: <span id="area">-</span></div>
                <div class="data-item">GDP: <span id="gdp">-</span></div>
                <div class="data-item">Capital: <span id="capital">-</span></div>
            </div>
        </div>
        
        <div class="performance-stats" id="perf-stats">
            <div>Frame Time: <span id="frame-time">0</span>ms</div>
            <div>Memory: <span id="memory-usage">0</span>MB</div>
            <div>Device: <span id="device-type">Desktop</span></div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let globePoints, wireframeGlobe;
        let autoRotate = false;
        let showWireframe = false;
        let performanceMode = false;
        let showDataDisplay = false;
        let selectedCountryId = -1;
        
        // Performance tracking
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;
        
        // Device detection and adaptive settings
        let deviceType = 'desktop';
        let isMobile = false;
        let isTablet = false;
        
        // Data structures
        let countryData = {};
        let pointAttributes = {
            positions: null,
            colors: null,
            countryIds: null,
            sizes: null
        };
        
        // Adaptive resolution settings
        const RESOLUTION_SETTINGS = {
            desktop: {
                maxPoints: 200000,
                textureSize: 4096,
                detailLevel: 'high'
            },
            tablet: {
                maxPoints: 100000,
                textureSize: 2048,
                detailLevel: 'medium'
            },
            mobile: {
                maxPoints: 50000,
                textureSize: 1024,
                detailLevel: 'low'
            }
        };
        
        let currentSettings = RESOLUTION_SETTINGS.desktop;
        
        // Initialize the application
        async function init() {
            updateProgress(10, "Detecting device capabilities...");
            
            // Detect device type and set adaptive settings
            detectDevice();
            
            updateProgress(20, "Initializing Three.js...");
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // Create renderer with adaptive settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isMobile,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1 : 2));
            document.getElementById('globe-container').appendChild(renderer.domElement);
            
            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            controls.autoRotateSpeed = 0.5;
            
            updateProgress(30, "Creating adaptive ID map...");
            
            // Create adaptive ID map based on device
            const idMapTexture = await createAdaptiveIDMap();
            
            updateProgress(50, "Generating point cloud...");
            
            // Generate Fibonacci sphere points with adaptive density
            const points = generateFibonacciSphere(currentSettings.maxPoints);
            
            updateProgress(70, "Pre-processing geometry...");
            
            // Pre-process geometry against ID map
            const processedPoints = await preprocessAdaptiveGeometry(points, idMapTexture);
            
            updateProgress(85, "Creating advanced shader material...");
            
            // Create advanced shader material
            createAdvancedShaderMaterial(processedPoints);
            
            updateProgress(95, "Setting up interactions...");
            
            // Setup mouse interactions
            setupMouseInteractions();
            
            // Create wireframe globe
            createWireframeGlobe();
            
            updateProgress(100, "Hybrid globe ready!");
            
            // Hide loading screen and show controls
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('info-panel').style.display = 'block';
                
                // Update statistics
                updateStatistics();
            }, 500);
            
            // Start animation loop
            animate();
        }
        
        // Detect device type and set adaptive settings
        function detectDevice() {
            const userAgent = navigator.userAgent;
            const screenWidth = window.innerWidth;
            
            if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
                if (screenWidth < 768) {
                    deviceType = 'mobile';
                    isMobile = true;
                    currentSettings = RESOLUTION_SETTINGS.mobile;
                } else {
                    deviceType = 'tablet';
                    isTablet = true;
                    currentSettings = RESOLUTION_SETTINGS.tablet;
                }
            } else {
                deviceType = 'desktop';
                currentSettings = RESOLUTION_SETTINGS.desktop;
            }
            
            document.getElementById('device-type').textContent = deviceType;
            document.getElementById('resolution').textContent = currentSettings.detailLevel;
            
            console.log(`Device detected: ${deviceType}, Settings: ${JSON.stringify(currentSettings)}`);
        }
        
        // Create adaptive ID map based on device capabilities
        async function createAdaptiveIDMap() {
            const canvas = document.createElement('canvas');
            canvas.width = currentSettings.textureSize;
            canvas.height = currentSettings.textureSize / 2;
            const ctx = canvas.getContext('2d');
            
            // Fill with black (ocean)
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Fill non-African landmass with red (1,0,0)
            ctx.fillStyle = 'rgb(1, 0, 0)';
            drawAllContinents(ctx, canvas.width, canvas.height);
            
            // Fill African countries with unique colors
            drawAfricanCountries(ctx, canvas.width, canvas.height);
            
            // Store canvas reference for later use
            window.idMapCanvas = canvas;
            
            // Convert to texture
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            console.log(`Adaptive ID Map created: ${canvas.width}x${canvas.height} for ${deviceType}`);
            return texture;
        }
        
        // Draw all continents with realistic shapes
        function drawAllContinents(ctx, width, height) {
            // North America
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.2);
            ctx.lineTo(width * 0.15, height * 0.15);
            ctx.lineTo(width * 0.25, height * 0.1);
            ctx.lineTo(width * 0.35, height * 0.12);
            ctx.lineTo(width * 0.4, height * 0.2);
            ctx.lineTo(width * 0.38, height * 0.35);
            ctx.lineTo(width * 0.35, height * 0.5);
            ctx.lineTo(width * 0.3, height * 0.6);
            ctx.lineTo(width * 0.25, height * 0.65);
            ctx.lineTo(width * 0.2, height * 0.6);
            ctx.lineTo(width * 0.15, height * 0.5);
            ctx.lineTo(width * 0.12, height * 0.4);
            ctx.lineTo(width * 0.1, height * 0.3);
            ctx.closePath();
            ctx.fill();
            
            // South America
            ctx.beginPath();
            ctx.moveTo(width * 0.15, height * 0.6);
            ctx.lineTo(width * 0.18, height * 0.55);
            ctx.lineTo(width * 0.22, height * 0.52);
            ctx.lineTo(width * 0.28, height * 0.5);
            ctx.lineTo(width * 0.32, height * 0.52);
            ctx.lineTo(width * 0.35, height * 0.58);
            ctx.lineTo(width * 0.33, height * 0.7);
            ctx.lineTo(width * 0.3, height * 0.8);
            ctx.lineTo(width * 0.25, height * 0.85);
            ctx.lineTo(width * 0.2, height * 0.82);
            ctx.lineTo(width * 0.18, height * 0.75);
            ctx.lineTo(width * 0.15, height * 0.68);
            ctx.closePath();
            ctx.fill();
            
            // Europe
            ctx.beginPath();
            ctx.moveTo(width * 0.45, height * 0.1);
            ctx.lineTo(width * 0.5, height * 0.08);
            ctx.lineTo(width * 0.55, height * 0.1);
            ctx.lineTo(width * 0.58, height * 0.15);
            ctx.lineTo(width * 0.57, height * 0.25);
            ctx.lineTo(width * 0.55, height * 0.35);
            ctx.lineTo(width * 0.52, height * 0.4);
            ctx.lineTo(width * 0.48, height * 0.38);
            ctx.lineTo(width * 0.45, height * 0.3);
            ctx.lineTo(width * 0.43, height * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Asia
            ctx.beginPath();
            ctx.moveTo(width * 0.6, height * 0.1);
            ctx.lineTo(width * 0.7, height * 0.08);
            ctx.lineTo(width * 0.85, height * 0.12);
            ctx.lineTo(width * 0.95, height * 0.2);
            ctx.lineTo(width * 0.98, height * 0.35);
            ctx.lineTo(width * 0.95, height * 0.5);
            ctx.lineTo(width * 0.9, height * 0.6);
            ctx.lineTo(width * 0.85, height * 0.65);
            ctx.lineTo(width * 0.8, height * 0.6);
            ctx.lineTo(width * 0.75, height * 0.5);
            ctx.lineTo(width * 0.7, height * 0.4);
            ctx.lineTo(width * 0.65, height * 0.3);
            ctx.lineTo(width * 0.62, height * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Australia
            ctx.beginPath();
            ctx.moveTo(width * 0.7, height * 0.7);
            ctx.lineTo(width * 0.75, height * 0.68);
            ctx.lineTo(width * 0.8, height * 0.7);
            ctx.lineTo(width * 0.82, height * 0.75);
            ctx.lineTo(width * 0.8, height * 0.8);
            ctx.lineTo(width * 0.75, height * 0.82);
            ctx.lineTo(width * 0.7, height * 0.8);
            ctx.lineTo(width * 0.68, height * 0.75);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw African countries with unique colors
        function drawAfricanCountries(ctx, width, height) {
            // North Africa
            drawCountryRegion(ctx, width * 0.45, height * 0.25, width * 0.12, height * 0.15, 2); // Algeria
            drawCountryRegion(ctx, width * 0.58, height * 0.25, width * 0.08, height * 0.12, 16); // Egypt
            drawCountryRegion(ctx, width * 0.48, height * 0.2, width * 0.1, height * 0.1, 36); // Morocco
            
            // West Africa
            drawCountryRegion(ctx, width * 0.42, height * 0.4, width * 0.08, height * 0.12, 40); // Nigeria
            drawCountryRegion(ctx, width * 0.38, height * 0.45, width * 0.06, height * 0.08, 23); // Ghana
            drawCountryRegion(ctx, width * 0.35, height * 0.4, width * 0.08, height * 0.1, 43); // Senegal
            
            // East Africa
            drawCountryRegion(ctx, width * 0.58, height * 0.45, width * 0.08, height * 0.1, 27); // Kenya
            drawCountryRegion(ctx, width * 0.62, height * 0.5, width * 0.1, height * 0.12, 50); // Tanzania
            
            // Central Africa
            drawCountryRegion(ctx, width * 0.52, height * 0.5, width * 0.12, height * 0.15, 14); // DRC
            drawCountryRegion(ctx, width * 0.48, height * 0.45, width * 0.08, height * 0.1, 8); // Cameroon
            
            // Southern Africa
            drawCountryRegion(ctx, width * 0.5, height * 0.7, width * 0.15, height * 0.12, 47); // South Africa
            drawCountryRegion(ctx, width * 0.52, height * 0.65, width * 0.1, height * 0.08, 5); // Botswana
            drawCountryRegion(ctx, width * 0.58, height * 0.68, width * 0.08, height * 0.1, 55); // Zimbabwe
        }
        
        // Draw a country region with specific ID
        function drawCountryRegion(ctx, x, y, width, height, countryId) {
            ctx.fillStyle = `rgb(${countryId}, 0, 0)`;
            ctx.fillRect(x, y, width, height);
        }
        
        // Generate Fibonacci sphere points
        function generateFibonacciSphere(numPoints) {
            const points = [];
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            
            for (let i = 0; i < numPoints; i++) {
                const y = 1 - (i / (numPoints - 1)) * 2;
                const radiusAtY = Math.sqrt(1 - y * y);
                
                const theta = goldenAngle * i;
                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            return points;
        }
        
        // Pre-process geometry against adaptive ID map
        async function preprocessAdaptiveGeometry(points, idMapTexture) {
            const canvas = window.idMapCanvas;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const processedPoints = [];
            const positions = [];
            const colors = [];
            const countryIds = [];
            const sizes = [];
            
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                
                // Convert 3D point to UV coordinates
                const uv = vector3ToUV(point);
                const x = Math.floor(uv.x * canvas.width);
                const y = Math.floor(uv.y * canvas.height);
                
                // Clamp coordinates
                const clampedX = Math.max(0, Math.min(canvas.width - 1, x));
                const clampedY = Math.max(0, Math.min(canvas.height - 1, y));
                
                // Get pixel color from ID map
                const pixelIndex = (clampedY * canvas.width + clampedX) * 4;
                const r = data[pixelIndex];
                const g = data[pixelIndex + 1];
                const b = data[pixelIndex + 2];
                
                // Skip ocean points (black)
                if (r === 0 && g === 0 && b === 0) {
                    continue;
                }
                
                // Scale point to globe surface
                const scaledPoint = point.clone().multiplyScalar(5);
                positions.push(scaledPoint.x, scaledPoint.y, scaledPoint.z);
                
                // Determine color based on country ID
                let color, countryId, size;
                
                if (r === 1 && g === 0 && b === 0) {
                    // Non-African landmass
                    color = new THREE.Color(0x666666);
                    countryId = 1;
                    size = 0.8;
                } else if (r >= 2 && r <= 55) {
                    // African country
                    countryId = r;
                    color = new THREE.Color(0x00ff88 + (countryId * 1000));
                    size = 1.2; // Larger size for African countries
                    
                    // Store country data
                    if (!countryData[countryId]) {
                        countryData[countryId] = {
                            name: `Country ${countryId}`,
                            points: 0,
                            color: color.getHex()
                        };
                    }
                    countryData[countryId].points++;
                } else {
                    // Unknown region
                    color = new THREE.Color(0x888888);
                    countryId = 0;
                    size = 0.6;
                }
                
                colors.push(color.r, color.g, color.b);
                countryIds.push(countryId);
                sizes.push(size);
                
                processedPoints.push({
                    position: scaledPoint,
                    color: color,
                    countryId: countryId,
                    size: size
                });
            }
            
            // Store attributes for shader
            pointAttributes.positions = new Float32Array(positions);
            pointAttributes.colors = new Float32Array(colors);
            pointAttributes.countryIds = new Float32Array(countryIds);
            pointAttributes.sizes = new Float32Array(sizes);
            
            console.log(`Processed ${processedPoints.length} points from ${points.length} total for ${deviceType}`);
            return processedPoints;
        }
        
        // Convert 3D vector to UV coordinates
        function vector3ToUV(vector) {
            const u = 0.5 + Math.atan2(vector.z, vector.x) / (2 * Math.PI);
            const v = 0.5 - Math.asin(vector.y) / Math.PI;
            return new THREE.Vector2(u, v);
        }
        
        // Create advanced shader material
        function createAdvancedShaderMaterial(points) {
            const geometry = new THREE.BufferGeometry();
            
            // Set attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(pointAttributes.positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(pointAttributes.colors, 3));
            geometry.setAttribute('countryId', new THREE.BufferAttribute(pointAttributes.countryIds, 1));
            geometry.setAttribute('size', new THREE.BufferAttribute(pointAttributes.sizes, 1));
            
            // Advanced shader material
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    selectedCountryId: { value: -1 },
                    time: { value: 0 },
                    performanceMode: { value: performanceMode }
                },
                vertexShader: `
                    attribute float size;
                    attribute float countryId;
                    uniform float selectedCountryId;
                    uniform float time;
                    uniform bool performanceMode;
                    
                    varying vec3 vColor;
                    varying float vOpacity;
                    varying float vCountryId;
                    
                    void main() {
                        vColor = color;
                        vCountryId = countryId;
                        
                        // Calculate opacity based on selection
                        if (selectedCountryId > 0.0) {
                            if (abs(countryId - selectedCountryId) < 0.5) {
                                vOpacity = 1.0;
                            } else if (countryId > 1.0) {
                                vOpacity = 0.4;
                            } else {
                                vOpacity = 0.15;
                            }
                        } else {
                            vOpacity = 0.9;
                        }
                        
                        // Add subtle animation
                        if (!performanceMode) {
                            float pulse = sin(time * 1.5 + position.x * 8.0) * 0.15 + 1.0;
                            gl_PointSize = size * 12.0 * pulse;
                        } else {
                            gl_PointSize = size * 10.0;
                        }
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vOpacity;
                    varying float vCountryId;
                    
                    void main() {
                        // Create soft circular points with glow
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.2, 0.5, dist);
                        alpha *= vOpacity;
                        
                        // Add glow for African countries
                        if (vCountryId > 1.0) {
                            float glow = 1.0 - smoothstep(0.0, 0.4, dist);
                            alpha += glow * 0.4;
                        }
                        
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true
            });
            
            globePoints = new THREE.Points(geometry, material);
            scene.add(globePoints);
        }
        
        // Create wireframe globe for reference
        function createWireframeGlobe() {
            const geometry = new THREE.SphereGeometry(5.1, 64, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x333333,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            
            wireframeGlobe = new THREE.Mesh(geometry, material);
            wireframeGlobe.visible = showWireframe;
            scene.add(wireframeGlobe);
        }
        
        // Setup mouse interactions
        function setupMouseInteractions() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Create a simple sphere for intersection testing
                const sphere = new THREE.SphereGeometry(5, 32, 32);
                const sphereMesh = new THREE.Mesh(sphere);
                
                const intersects = raycaster.intersectObject(sphereMesh);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const uv = vector3ToUV(point.normalize());
                    
                    // Sample ID map at intersection point
                    const countryId = sampleIDMap(uv);
                    
                    if (countryId !== selectedCountryId) {
                        selectedCountryId = countryId;
                        updateCountrySelection();
                    }
                }
            }
            
            window.addEventListener('mousemove', onMouseMove);
        }
        
        // Sample ID map at UV coordinates
        function sampleIDMap(uv) {
            // This would sample the actual ID map texture
            // For now, return a mock country ID based on position
            if (uv.x > 0.4 && uv.x < 0.6 && uv.y > 0.3 && uv.y < 0.7) {
                return Math.floor(Math.random() * 54) + 2; // Random African country
            }
            return 1; // Non-African landmass
        }
        
        // Update country selection
        function updateCountrySelection() {
            if (globePoints && globePoints.material.uniforms) {
                globePoints.material.uniforms.selectedCountryId.value = selectedCountryId;
            }
            
            // Update UI
            const countryInfo = document.getElementById('country-info');
            if (selectedCountryId > 1 && countryData[selectedCountryId]) {
                const country = countryData[selectedCountryId];
                document.getElementById('country-name').textContent = country.name;
                document.getElementById('country-id').textContent = `ID: ${selectedCountryId}`;
                document.getElementById('country-points').textContent = `Points: ${country.points}`;
                countryInfo.style.display = 'block';
                
                // Update data panel if visible
                if (showDataDisplay) {
                    updateDataPanel(selectedCountryId);
                }
            } else {
                countryInfo.style.display = 'none';
            }
        }
        
        // Update data panel with country information
        function updateDataPanel(countryId) {
            // Mock data - in real implementation, this would come from an API
            const mockData = {
                population: Math.floor(Math.random() * 100000000),
                area: Math.floor(Math.random() * 1000000),
                gdp: Math.floor(Math.random() * 1000000000000),
                capital: `Capital ${countryId}`
            };
            
            document.getElementById('population').textContent = mockData.population.toLocaleString();
            document.getElementById('area').textContent = mockData.area.toLocaleString() + ' km²';
            document.getElementById('gdp').textContent = '$' + mockData.gdp.toLocaleString();
            document.getElementById('capital').textContent = mockData.capital;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update FPS
            frameCount++;
            if (frameCount % 60 === 0) {
                fps = Math.round(1000 / deltaTime);
                document.getElementById('fps').textContent = fps;
                
                // Auto-enable performance mode if FPS drops
                if (fps < 30 && !performanceMode && !isMobile) {
                    togglePerformanceMode();
                }
            }
            
            // Update shader time
            if (globePoints && globePoints.material.uniforms) {
                globePoints.material.uniforms.time.value = currentTime * 0.001;
                globePoints.material.uniforms.performanceMode.value = performanceMode;
            }
            
            // Auto rotate
            if (autoRotate) {
                globePoints.rotation.y += 0.003;
                if (wireframeGlobe) {
                    wireframeGlobe.rotation.y += 0.003;
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
            
            // Update performance stats
            updatePerformanceStats(deltaTime);
        }
        
        // Update progress bar
        function updateProgress(percent, text) {
            document.getElementById('progress-bar').style.width = percent + '%';
            document.getElementById('loading-text').textContent = text;
        }
        
        // Update statistics
        function updateStatistics() {
            document.getElementById('total-points').textContent = pointAttributes.positions ? pointAttributes.positions.length / 3 : 0;
            document.getElementById('active-points').textContent = Object.keys(countryData).length;
        }
        
        // Update performance statistics
        function updatePerformanceStats(frameTime) {
            document.getElementById('frame-time').textContent = frameTime.toFixed(1);
            
            // Mock memory usage
            const memoryUsage = (pointAttributes.positions ? pointAttributes.positions.length * 4 : 0) / 1024 / 1024;
            document.getElementById('memory-usage').textContent = memoryUsage.toFixed(1);
        }
        
        // Control functions
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            document.getElementById('rotate-btn').classList.toggle('active', autoRotate);
        }
        
        function toggleWireframe() {
            showWireframe = !showWireframe;
            if (wireframeGlobe) {
                wireframeGlobe.visible = showWireframe;
            }
            document.getElementById('wireframe-btn').classList.toggle('active', showWireframe);
        }
        
        function togglePerformanceMode() {
            performanceMode = !performanceMode;
            document.getElementById('perf-btn').classList.toggle('active', performanceMode);
            
            // Adjust quality settings
            if (performanceMode) {
                renderer.setPixelRatio(1);
                if (globePoints) {
                    globePoints.material.uniforms.performanceMode.value = true;
                }
            } else {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1 : 2));
                if (globePoints) {
                    globePoints.material.uniforms.performanceMode.value = false;
                }
            }
        }
        
        function toggleDataDisplay() {
            showDataDisplay = !showDataDisplay;
            const dataPanel = document.getElementById('data-panel');
            dataPanel.style.display = showDataDisplay ? 'block' : 'none';
            document.getElementById('data-btn').classList.toggle('active', showDataDisplay);
            
            if (showDataDisplay && selectedCountryId > 1) {
                updateDataPanel(selectedCountryId);
            }
        }
        
        function resetView() {
            camera.position.set(0, 0, 15);
            controls.reset();
            selectedCountryId = -1;
            updateCountrySelection();
        }
        
        function exportData() {
            const data = {
                countries: countryData,
                totalPoints: pointAttributes.positions ? pointAttributes.positions.length / 3 : 0,
                deviceType: deviceType,
                settings: currentSettings,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hybrid-globe-data.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>

