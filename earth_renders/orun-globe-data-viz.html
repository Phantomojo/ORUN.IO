<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORUN Globe - Data Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 14px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 18px;
            z-index: 1000;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .controls button {
            background: #333;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .controls button:hover {
            background: #00ff00;
            color: #000;
        }
        
        .controls select {
            background: #333;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px;
            margin: 4px;
            border-radius: 4px;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            pointer-events: none;
            z-index: 1001;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading ORUN Globe - Data Visualization...</div>
        <div id="info" style="display: none;">
            <h3>ORUN GLOBE - DATA VISUALIZATION</h3>
            <p>Interactive data points and arcs</p>
            <p>FPS: <span id="fps">0</span></p>
            <p>Data Points: <span id="dataPoints">0</span></p>
            <p>Arcs: <span id="arcs">0</span></p>
        </div>
        <div class="controls" style="display: none;">
            <button onclick="toggleDataPoints()">Toggle Data Points</button>
            <button onclick="toggleArcs()">Toggle Arcs</button>
            <button onclick="animateData()">Animate Data</button>
            <button onclick="resetCamera()">Reset Camera</button>
            <select onchange="changeDataset(this.value)">
                <option value="cities">Cities</option>
                <option value="connections">Connections</option>
                <option value="heatmap">Heatmap</option>
            </select>
        </div>
        <div id="tooltip"></div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let earth, dataPoints, arcs, tooltip;
        let dataPointsVisible = true;
        let arcsVisible = true;
        let currentDataset = 'cities';
        let stats = { fps: 0, dataPointCount: 0, arcCount: 0 };
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        
        // Sample data
        const datasets = {
            cities: [
                { name: 'New York', lat: 40.7128, lng: -74.0060, value: 100 },
                { name: 'London', lat: 51.5074, lng: -0.1278, value: 80 },
                { name: 'Tokyo', lat: 35.6762, lng: 139.6503, value: 90 },
                { name: 'Sydney', lat: -33.8688, lng: 151.2093, value: 70 },
                { name: 'São Paulo', lat: -23.5505, lng: -46.6333, value: 60 },
                { name: 'Mumbai', lat: 19.0760, lng: 72.8777, value: 85 },
                { name: 'Cairo', lat: 30.0444, lng: 31.2357, value: 50 },
                { name: 'Moscow', lat: 55.7558, lng: 37.6176, value: 75 }
            ],
            connections: [
                { from: 'New York', to: 'London', value: 50 },
                { from: 'London', to: 'Tokyo', value: 40 },
                { from: 'Tokyo', to: 'Sydney', value: 30 },
                { from: 'Sydney', to: 'São Paulo', value: 25 },
                { from: 'São Paulo', to: 'Mumbai', value: 35 },
                { from: 'Mumbai', to: 'Cairo', value: 20 },
                { from: 'Cairo', to: 'Moscow', value: 15 },
                { from: 'Moscow', to: 'New York', value: 45 }
            ],
            heatmap: [
                { lat: 40.7128, lng: -74.0060, intensity: 0.9 },
                { lat: 51.5074, lng: -0.1278, intensity: 0.8 },
                { lat: 35.6762, lng: 139.6503, intensity: 0.7 },
                { lat: -33.8688, lng: 151.2093, intensity: 0.6 },
                { lat: -23.5505, lng: -46.6333, intensity: 0.5 },
                { lat: 19.0760, lng: 72.8777, intensity: 0.8 },
                { lat: 30.0444, lng: 31.2357, intensity: 0.4 },
                { lat: 55.7558, lng: 37.6176, intensity: 0.6 }
            ]
        };
        
        // Initialize the application
        function init() {
            console.log('Initializing ORUN Globe - Data Visualization...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                60, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 0, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            controls.minDistance = 8;
            controls.maxDistance = 50;
            controls.minPolarAngle = 0.1;
            controls.maxPolarAngle = Math.PI - 0.1;
            
            // Add lighting
            setupLighting();
            
            // Create Earth
            createEarth();
            
            // Create data visualization
            createDataVisualization();
            
            // Setup mouse interaction
            setupMouseInteraction();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start animation loop
            animate();
            
            // Hide loading and show UI
            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.querySelector('.controls').style.display = 'block';
            
            console.log('ORUN Globe - Data Visualization initialized successfully!');
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
        }
        
        function createEarth() {
            // Create Earth geometry
            const geometry = new THREE.SphereGeometry(5, 64, 64);
            
            // Create Earth material
            const material = new THREE.MeshPhongMaterial({
                color: 0x1e3a8a,
                shininess: 100,
                transparent: false
            });
            
            // Create Earth mesh
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);
        }
        
        function createDataVisualization() {
            // Clear existing data
            if (dataPoints) {
                scene.remove(dataPoints);
            }
            if (arcs) {
                scene.remove(arcs);
            }
            
            // Create data points
            createDataPoints();
            
            // Create arcs if connections dataset
            if (currentDataset === 'connections') {
                createArcs();
            }
        }
        
        function createDataPoints() {
            const points = [];
            const colors = [];
            const sizes = [];
            
            const data = datasets[currentDataset];
            
            data.forEach(item => {
                // Convert lat/lng to 3D coordinates
                const phi = (90 - item.lat) * (Math.PI / 180);
                const theta = (item.lng + 180) * (Math.PI / 180);
                
                const x = 5.1 * Math.sin(phi) * Math.cos(theta);
                const y = 5.1 * Math.cos(phi);
                const z = 5.1 * Math.sin(phi) * Math.sin(theta);
                
                points.push(x, y, z);
                
                // Color based on value/intensity
                const value = item.value || item.intensity || 1;
                const normalizedValue = value / 100;
                
                if (currentDataset === 'heatmap') {
                    // Heatmap colors (red to yellow)
                    colors.push(normalizedValue, normalizedValue * 0.5, 0);
                } else {
                    // Standard colors (green to blue)
                    colors.push(0.2, 0.8, normalizedValue);
                }
                
                // Size based on value
                sizes.push(normalizedValue * 0.2 + 0.1);
            });
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            dataPoints = new THREE.Points(geometry, material);
            scene.add(dataPoints);
            
            stats.dataPointCount = points.length / 3;
        }
        
        function createArcs() {
            const arcGroup = new THREE.Group();
            const data = datasets.connections;
            
            data.forEach(connection => {
                const fromCity = datasets.cities.find(city => city.name === connection.from);
                const toCity = datasets.cities.find(city => city.name === connection.to);
                
                if (fromCity && toCity) {
                    const arc = createArc(fromCity, toCity, connection.value);
                    arcGroup.add(arc);
                }
            });
            
            arcs = arcGroup;
            scene.add(arcs);
            
            stats.arcCount = data.length;
        }
        
        function createArc(fromCity, toCity, value) {
            // Convert lat/lng to 3D coordinates
            const fromPhi = (90 - fromCity.lat) * (Math.PI / 180);
            const fromTheta = (fromCity.lng + 180) * (Math.PI / 180);
            const toPhi = (90 - toCity.lat) * (Math.PI / 180);
            const toTheta = (toCity.lng + 180) * (Math.PI / 180);
            
            const fromX = 5.1 * Math.sin(fromPhi) * Math.cos(fromTheta);
            const fromY = 5.1 * Math.cos(fromPhi);
            const fromZ = 5.1 * Math.sin(fromPhi) * Math.sin(fromTheta);
            
            const toX = 5.1 * Math.sin(toPhi) * Math.cos(toTheta);
            const toY = 5.1 * Math.cos(toPhi);
            const toZ = 5.1 * Math.sin(toPhi) * Math.sin(toTheta);
            
            // Create arc geometry
            const points = [];
            const segments = 20;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = fromX + (toX - fromX) * t;
                const y = fromY + (toY - fromY) * t + Math.sin(t * Math.PI) * 2;
                const z = fromZ + (toZ - fromZ) * t;
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: value / 100
            });
            
            return new THREE.Line(geometry, material);
        }
        
        function setupMouseInteraction() {
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('click', onMouseClick, false);
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            if (dataPoints) {
                const intersects = raycaster.intersectObject(dataPoints);
                
                if (intersects.length > 0) {
                    const point = intersects[0];
                    const index = point.index;
                    const data = datasets[currentDataset][index];
                    
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 10 + 'px';
                    tooltip.style.top = event.clientY - 10 + 'px';
                    tooltip.innerHTML = `
                        <strong>${data.name || 'Data Point'}</strong><br>
                        Value: ${data.value || data.intensity || 'N/A'}<br>
                        Lat: ${data.lat.toFixed(2)}°, Lng: ${data.lng.toFixed(2)}°
                    `;
                } else {
                    tooltip.style.display = 'none';
                }
            }
        }
        
        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            
            if (dataPoints) {
                const intersects = raycaster.intersectObject(dataPoints);
                
                if (intersects.length > 0) {
                    const point = intersects[0];
                    const index = point.index;
                    const data = datasets[currentDataset][index];
                    
                    console.log('Clicked on:', data);
                    
                    // Animate camera to focus on the point
                    animateToPoint(data);
                }
            }
        }
        
        function animateToPoint(data) {
            const phi = (90 - data.lat) * (Math.PI / 180);
            const theta = (data.lng + 180) * (Math.PI / 180);
            
            const targetX = 5.1 * Math.sin(phi) * Math.cos(theta);
            const targetY = 5.1 * Math.cos(phi);
            const targetZ = 5.1 * Math.sin(phi) * Math.sin(theta);
            
            const targetPosition = new THREE.Vector3(targetX * 2, targetY * 2, targetZ * 2);
            
            gsap.to(camera.position, {
                duration: 2,
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                ease: "power2.inOut"
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Rotate Earth
            if (earth) {
                earth.rotation.y += 0.001;
            }
            
            // Update stats
            updateStats();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        function updateStats() {
            stats.fps = Math.round(1000 / (performance.now() - (stats.lastTime || performance.now())));
            stats.lastTime = performance.now();
            
            document.getElementById('fps').textContent = stats.fps;
            document.getElementById('dataPoints').textContent = stats.dataPointCount;
            document.getElementById('arcs').textContent = stats.arcCount;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Control functions
        function toggleDataPoints() {
            dataPointsVisible = !dataPointsVisible;
            if (dataPoints) {
                dataPoints.visible = dataPointsVisible;
            }
        }
        
        function toggleArcs() {
            arcsVisible = !arcsVisible;
            if (arcs) {
                arcs.visible = arcsVisible;
            }
        }
        
        function animateData() {
            if (dataPoints) {
                gsap.to(dataPoints.rotation, {
                    duration: 2,
                    y: dataPoints.rotation.y + Math.PI * 2,
                    ease: "power2.inOut"
                });
            }
        }
        
        function resetCamera() {
            camera.position.set(0, 0, 15);
            controls.reset();
        }
        
        function changeDataset(dataset) {
            currentDataset = dataset;
            createDataVisualization();
            console.log('Dataset changed to:', dataset);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
