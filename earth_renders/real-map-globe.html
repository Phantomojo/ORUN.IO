<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Map Globe - Accurate Geographic Projection</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #globe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }
        
        .controls h3 {
            margin: 0 0 15px 0;
            color: #00ff88;
            font-size: 18px;
        }
        
        .controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            background: #111;
            color: #fff;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .controls button:hover {
            background: #222;
            border-color: #00ff88;
        }
        
        .controls button.active {
            background: #00ff88;
            color: #000;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            min-width: 250px;
        }
        
        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        .info-panel .stat {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
        }
        
        .loading h2 {
            color: #00ff88;
            margin-bottom: 20px;
        }
        
        .loading .progress {
            width: 300px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading .progress-bar {
            height: 100%;
            background: #00ff88;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .performance-stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            font-size: 12px;
        }
        
        .map-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            min-width: 200px;
        }
        
        .map-info h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        .map-info .info-item {
            margin: 5px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="globe-container"></div>
        
        <div class="loading" id="loading">
            <h2>Loading Real Map Globe</h2>
            <div class="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div id="loading-text">Loading...</div>
        </div>
        
        <div class="controls" id="controls" style="display: none;">
            <h3>Map Globe Controls</h3>
            <button onclick="toggleAutoRotate()" id="rotate-btn">Auto Rotate</button>
            <button onclick="toggleWireframe()" id="wireframe-btn">Show Wireframe</button>
            <button onclick="toggleNightMode()" id="night-btn">Night Mode</button>
            <button onclick="toggleAtmosphere()" id="atmosphere-btn">Atmosphere</button>
            <button onclick="resetView()">Reset View</button>
            <button onclick="changeMapStyle()">Change Map Style</button>
        </div>
        
        <div class="info-panel" id="info-panel" style="display: none;">
            <h4>Globe Statistics</h4>
            <div class="stat">Map Resolution: <span id="map-resolution">2048x1024</span></div>
            <div class="stat">Sphere Segments: <span id="sphere-segments">64x32</span></div>
            <div class="stat">FPS: <span id="fps">0</span></div>
            <div class="stat">Render Mode: <span id="render-mode">Textured</span></div>
        </div>
        
        <div class="map-info" id="map-info">
            <h4>Map Information</h4>
            <div class="info-item">Projection: Equirectangular</div>
            <div class="info-item">Source: Natural Earth</div>
            <div class="info-item">Format: WebGL Texture</div>
            <div class="info-item">Wrapping: Seamless</div>
        </div>
        
        <div class="performance-stats" id="perf-stats">
            <div>Frame Time: <span id="frame-time">0</span>ms</div>
            <div>Memory: <span id="memory-usage">0</span>MB</div>
            <div>Texture Size: <span id="texture-size">2048x1024</span></div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let earth, atmosphere, wireframe;
        let autoRotate = false;
        let showWireframe = false;
        let nightMode = false;
        let showAtmosphere = false;
        let currentMapStyle = 0;
        
        // Performance tracking
        let frameCount = 0;
        let lastTime = 0;
        let fps = 0;
        
        // Map styles - different world map textures
        const MAP_STYLES = [
            {
                name: "Natural Earth",
                url: "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/img/background/World_map.png",
                description: "Natural Earth physical map"
            },
            {
                name: "Political",
                url: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/World_map_-_low_resolution.svg/2048px-World_map_-_low_resolution.svg.png",
                description: "Political world map"
            },
            {
                name: "Satellite",
                url: "https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg",
                description: "NASA satellite imagery"
            },
            {
                name: "Blue Marble",
                url: "https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73963/earth_lights_lrg.jpg",
                description: "NASA Blue Marble"
            }
        ];
        
        // Initialize the application
        async function init() {
            updateProgress(10, "Initializing Three.js...");
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('globe-container').appendChild(renderer.domElement);
            
            // Create controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            controls.autoRotateSpeed = 0.5;
            controls.minDistance = 8;
            controls.maxDistance = 50;
            
            updateProgress(30, "Loading world map texture...");
            
            // Load world map texture
            const mapTexture = await loadWorldMapTexture();
            
            updateProgress(60, "Creating 3D globe...");
            
            // Create the Earth sphere with real map texture
            createEarthGlobe(mapTexture);
            
            updateProgress(80, "Adding atmosphere and effects...");
            
            // Create atmosphere
            createAtmosphere();
            
            // Create wireframe
            createWireframe();
            
            updateProgress(100, "Real map globe ready!");
            
            // Hide loading screen and show controls
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                document.getElementById('info-panel').style.display = 'block';
            }, 500);
            
            // Start animation loop
            animate();
        }
        
        // Load world map texture
        async function loadWorldMapTexture() {
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                const currentMap = MAP_STYLES[currentMapStyle];
                
                loader.load(
                    currentMap.url,
                    (texture) => {
                        // Configure texture for proper wrapping
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        texture.minFilter = THREE.LinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        
                        console.log(`Loaded map: ${currentMap.name}`);
                        resolve(texture);
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateProgress(30 + (percent * 0.3), `Loading map texture... ${percent}%`);
                    },
                    (error) => {
                        console.error('Error loading map texture:', error);
                        // Fallback to a simple colored texture
                        const canvas = createFallbackTexture();
                        const texture = new THREE.CanvasTexture(canvas);
                        resolve(texture);
                    }
                );
            });
        }
        
        // Create fallback texture if map loading fails
        function createFallbackTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Create a simple world map pattern
            ctx.fillStyle = '#001122'; // Ocean
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add continents
            ctx.fillStyle = '#228833'; // Land
            drawSimpleContinents(ctx, canvas.width, canvas.height);
            
            return canvas;
        }
        
        // Draw simple continent shapes
        function drawSimpleContinents(ctx, width, height) {
            // North America
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.2);
            ctx.lineTo(width * 0.15, height * 0.15);
            ctx.lineTo(width * 0.25, height * 0.1);
            ctx.lineTo(width * 0.35, height * 0.12);
            ctx.lineTo(width * 0.4, height * 0.2);
            ctx.lineTo(width * 0.38, height * 0.35);
            ctx.lineTo(width * 0.35, height * 0.5);
            ctx.lineTo(width * 0.3, height * 0.6);
            ctx.lineTo(width * 0.25, height * 0.65);
            ctx.lineTo(width * 0.2, height * 0.6);
            ctx.lineTo(width * 0.15, height * 0.5);
            ctx.lineTo(width * 0.12, height * 0.4);
            ctx.lineTo(width * 0.1, height * 0.3);
            ctx.closePath();
            ctx.fill();
            
            // South America
            ctx.beginPath();
            ctx.moveTo(width * 0.15, height * 0.6);
            ctx.lineTo(width * 0.18, height * 0.55);
            ctx.lineTo(width * 0.22, height * 0.52);
            ctx.lineTo(width * 0.28, height * 0.5);
            ctx.lineTo(width * 0.32, height * 0.52);
            ctx.lineTo(width * 0.35, height * 0.58);
            ctx.lineTo(width * 0.33, height * 0.7);
            ctx.lineTo(width * 0.3, height * 0.8);
            ctx.lineTo(width * 0.25, height * 0.85);
            ctx.lineTo(width * 0.2, height * 0.82);
            ctx.lineTo(width * 0.18, height * 0.75);
            ctx.lineTo(width * 0.15, height * 0.68);
            ctx.closePath();
            ctx.fill();
            
            // Europe
            ctx.beginPath();
            ctx.moveTo(width * 0.45, height * 0.1);
            ctx.lineTo(width * 0.5, height * 0.08);
            ctx.lineTo(width * 0.55, height * 0.1);
            ctx.lineTo(width * 0.58, height * 0.15);
            ctx.lineTo(width * 0.57, height * 0.25);
            ctx.lineTo(width * 0.55, height * 0.35);
            ctx.lineTo(width * 0.52, height * 0.4);
            ctx.lineTo(width * 0.48, height * 0.38);
            ctx.lineTo(width * 0.45, height * 0.3);
            ctx.lineTo(width * 0.43, height * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Asia
            ctx.beginPath();
            ctx.moveTo(width * 0.6, height * 0.1);
            ctx.lineTo(width * 0.7, height * 0.08);
            ctx.lineTo(width * 0.85, height * 0.12);
            ctx.lineTo(width * 0.95, height * 0.2);
            ctx.lineTo(width * 0.98, height * 0.35);
            ctx.lineTo(width * 0.95, height * 0.5);
            ctx.lineTo(width * 0.9, height * 0.6);
            ctx.lineTo(width * 0.85, height * 0.65);
            ctx.lineTo(width * 0.8, height * 0.6);
            ctx.lineTo(width * 0.75, height * 0.5);
            ctx.lineTo(width * 0.7, height * 0.4);
            ctx.lineTo(width * 0.65, height * 0.3);
            ctx.lineTo(width * 0.62, height * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Africa
            ctx.beginPath();
            ctx.moveTo(width * 0.45, height * 0.25);
            ctx.lineTo(width * 0.48, height * 0.2);
            ctx.lineTo(width * 0.52, height * 0.22);
            ctx.lineTo(width * 0.55, height * 0.25);
            ctx.lineTo(width * 0.58, height * 0.3);
            ctx.lineTo(width * 0.57, height * 0.4);
            ctx.lineTo(width * 0.55, height * 0.5);
            ctx.lineTo(width * 0.52, height * 0.6);
            ctx.lineTo(width * 0.48, height * 0.65);
            ctx.lineTo(width * 0.45, height * 0.6);
            ctx.lineTo(width * 0.42, height * 0.5);
            ctx.lineTo(width * 0.43, height * 0.4);
            ctx.lineTo(width * 0.45, height * 0.3);
            ctx.closePath();
            ctx.fill();
            
            // Australia
            ctx.beginPath();
            ctx.moveTo(width * 0.7, height * 0.7);
            ctx.lineTo(width * 0.75, height * 0.68);
            ctx.lineTo(width * 0.8, height * 0.7);
            ctx.lineTo(width * 0.82, height * 0.75);
            ctx.lineTo(width * 0.8, height * 0.8);
            ctx.lineTo(width * 0.75, height * 0.82);
            ctx.lineTo(width * 0.7, height * 0.8);
            ctx.lineTo(width * 0.68, height * 0.75);
            ctx.closePath();
            ctx.fill();
        }
        
        // Create the Earth globe with real map texture
        function createEarthGlobe(mapTexture) {
            // Create sphere geometry with high detail
            const geometry = new THREE.SphereGeometry(5, 64, 32);
            
            // Create material with the world map texture
            const material = new THREE.MeshPhongMaterial({
                map: mapTexture,
                transparent: false,
                shininess: 0,
                specular: new THREE.Color(0x111111)
            });
            
            // Create the Earth mesh
            earth = new THREE.Mesh(geometry, material);
            earth.castShadow = true;
            earth.receiveShadow = true;
            scene.add(earth);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            console.log("Earth globe created with real map texture");
        }
        
        // Create atmosphere effect
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(5.1, 32, 16);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    uniform float time;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                        gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            atmosphere.visible = showAtmosphere;
            scene.add(atmosphere);
        }
        
        // Create wireframe
        function createWireframe() {
            const geometry = new THREE.SphereGeometry(5.05, 32, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x333333,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            
            wireframe = new THREE.Mesh(geometry, material);
            wireframe.visible = showWireframe;
            scene.add(wireframe);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update FPS
            frameCount++;
            if (frameCount % 60 === 0) {
                fps = Math.round(1000 / deltaTime);
                document.getElementById('fps').textContent = fps;
            }
            
            // Auto rotate
            if (autoRotate) {
                earth.rotation.y += 0.005;
                if (atmosphere) {
                    atmosphere.rotation.y += 0.005;
                }
                if (wireframe) {
                    wireframe.rotation.y += 0.005;
                }
            }
            
            // Update atmosphere shader
            if (atmosphere && atmosphere.material.uniforms) {
                atmosphere.material.uniforms.time.value = currentTime * 0.001;
            }
            
            controls.update();
            renderer.render(scene, camera);
            
            // Update performance stats
            updatePerformanceStats(deltaTime);
        }
        
        // Update progress bar
        function updateProgress(percent, text) {
            document.getElementById('progress-bar').style.width = percent + '%';
            document.getElementById('loading-text').textContent = text;
        }
        
        // Update performance statistics
        function updatePerformanceStats(frameTime) {
            document.getElementById('frame-time').textContent = frameTime.toFixed(1);
            
            // Mock memory usage
            const memoryUsage = 50 + Math.random() * 10; // Simulate memory usage
            document.getElementById('memory-usage').textContent = memoryUsage.toFixed(1);
        }
        
        // Control functions
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            controls.autoRotate = autoRotate;
            document.getElementById('rotate-btn').classList.toggle('active', autoRotate);
        }
        
        function toggleWireframe() {
            showWireframe = !showWireframe;
            if (wireframe) {
                wireframe.visible = showWireframe;
            }
            document.getElementById('wireframe-btn').classList.toggle('active', showWireframe);
        }
        
        function toggleNightMode() {
            nightMode = !nightMode;
            if (nightMode) {
                scene.background = new THREE.Color(0x000000);
                document.getElementById('night-btn').classList.add('active');
            } else {
                scene.background = new THREE.Color(0x000011);
                document.getElementById('night-btn').classList.remove('active');
            }
        }
        
        function toggleAtmosphere() {
            showAtmosphere = !showAtmosphere;
            if (atmosphere) {
                atmosphere.visible = showAtmosphere;
            }
            document.getElementById('atmosphere-btn').classList.toggle('active', showAtmosphere);
        }
        
        function resetView() {
            camera.position.set(0, 0, 15);
            controls.reset();
        }
        
        async function changeMapStyle() {
            currentMapStyle = (currentMapStyle + 1) % MAP_STYLES.length;
            const newMap = MAP_STYLES[currentMapStyle];
            
            document.getElementById('loading').style.display = 'block';
            updateProgress(50, `Loading ${newMap.name}...`);
            
            try {
                const newTexture = await loadWorldMapTexture();
                earth.material.map = newTexture;
                earth.material.needsUpdate = true;
                
                document.getElementById('loading').style.display = 'none';
                console.log(`Switched to ${newMap.name}`);
            } catch (error) {
                console.error('Error changing map style:', error);
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>

